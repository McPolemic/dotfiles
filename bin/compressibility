#!/usr/bin/env -S uv run

# By Gary Bernhardt.
# Dotfiles at: https://github.com/garybernhardt/dotfiles

# /// script
# requires-python = ">=3.11"
# dependencies = [
#   "brotli",
#   "humanfriendly",
# ]
# ///

import sys
import zlib
import bz2
import brotli
import lzma
import humanfriendly
import concurrent.futures

def compress_zlib(data: bytes) -> int:
    return len(zlib.compress(data))

def compress_bz2(data: bytes) -> int:
    return len(bz2.compress(data))

def compress_brotli(data: bytes) -> int:
    return len(brotli.compress(data))

def compress_xz(data: bytes) -> int:
    return len(lzma.compress(data))

def main():
    data = file_data()
    size = len(data)
    print('file size', humanfriendly.format_size(size))

    # list of (label, function) pairs
    compressors = [
        ('gzip',      compress_zlib),
        ('bz2',       compress_bz2),
        ('brotli',    compress_brotli),
        ('xz',        compress_xz),
    ]

    # run them in parallel
    results = {}
    with concurrent.futures.ProcessPoolExecutor() as executor:
        # submit all jobs
        future_to_name = {
            executor.submit(func, data): name
            for name, func in compressors
        }
        # as they finish, store the result
        for future in concurrent.futures.as_completed(future_to_name):
            name = future_to_name[future]
            try:
                results[name] = future.result()
            except Exception as e:
                # fallback if something goes wrong
                print(f"{name} compression failed: {e}", file=sys.stderr)
                results[name] = 0

    # print them in a consistent order
    for name, _ in compressors:
        comp_size = results.get(name, 0)
        print(f"{name} size {humanfriendly.format_size(comp_size)} ({percent(comp_size, size)}%)")

def file_data():
    args = sys.argv[1:]
    if not args or args == ['-'] or '-' in args:
        return sys.stdin.buffer.read()

    parts = []
    stdin_data = None
    for name in args:
        if name == '-':
            if stdin_data is None:
                stdin_data = sys.stdin.buffer.read()
            parts.append(stdin_data)
        else:
            try:
                with open(name, 'rb') as f:
                    parts.append(f.read())
            except FileNotFoundError:
                if stdin_data is None:
                    stdin_data = sys.stdin.buffer.read()
                parts.append(stdin_data)
    return b''.join(parts)

def percent(part, whole):
    if whole == 0:
        return 0
    return int(100.0 * part / whole)

if __name__ == '__main__':
    main()